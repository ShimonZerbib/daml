// Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

//
// Protocol buffer messages used by the participant state key-value utilities
// for implementing a Daml ledger backed by a key-value store.
//
// These messages should only be produced and consumed by the methods in
// `KeyValueCommitting`, `KeyValueConsumption` and `KeyValueSubmission` objects.
//

syntax = "proto3";

package com.daml.ledger.participant.state.kvutils;

option java_package = "com.daml.ledger.participant.state.kvutils";
option csharp_namespace = "Com.Daml.Ledger.Participant.State.KVUtils";

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "com/daml/daml_lf_dev/daml_lf.proto";
import "com/daml/lf/transaction.proto";
import "com/daml/ledger/participant/state/kvutils/rejection_reason.proto";
import "com/daml/ledger/participant/state/kvutils/daml_configuration.proto";
import "com/daml/ledger/participant/state/kvutils/daml_configuration_rejection.proto";
// Envelope with which we wrap all kvutils messages that are sent over the network
// or persisted on disk. The envelope specifies the kvutils version that defines how
// a message is decoded and processed. Optionally the message payload may be stored
// compressed.
message Envelope {
  enum MessageKind {
    SUBMISSION = 0;
    LOG_ENTRY = 1;
    STATE_VALUE = 2;
    SUBMISSION_BATCH = 3;
  }

  enum CompressionSchema {
    NONE = 0;
    GZIP = 1;
  }

  // Kvutils version number
  int64 version = 1;

  // Kind of message contained within.
  MessageKind kind = 2;

  // Compression schema, if any, used to compress the message.
  CompressionSchema compression = 3;

  // The enclosed, potentially compressed, message
  bytes message = 4;
}

// A log entry for a committed Daml submission.
// Produced by [[KeyValueCommitting]] from the `DamlSubmission` message.
// Each entry can be converted into a participant state `Update` event
// with [[KeyValueConsumption]], except for a time update entry.
//
// Please read comments in [[com.daml.ledger.participant.state.v2.package]]
// and  [[com.daml.ledger.participant.state.kvutils.package]] for background
// information.
message DamlLogEntry {
  // The record time at which this entry was committed.
  google.protobuf.Timestamp record_time = 1;

  oneof payload {
    // A committed Daml transaction.
    // Can be converted into `Update.TransactionAccepted`.
    DamlTransactionEntry transaction_entry = 2;

    // A rejected transaction.
    DamlTransactionRejectionEntry transaction_rejection_entry = 3;

    // A collection of Daml-LF archives uploaded together by a participant.
    DamlPackageUploadEntry package_upload_entry = 4;

    // A rejection of package upload.
    DamlPackageUploadRejectionEntry package_upload_rejection_entry = 5;

    // A Daml ledger configuration change.
    DamlConfigurationEntry configuration_entry = 6;

    // A rejected configuration change.
    DamlConfigurationRejectionEntry configuration_rejection_entry = 7;

    // Allocation of a new Daml party and its assignment to a participant.
    DamlPartyAllocationEntry party_allocation_entry = 8;

    // A rejection of party allocation request.
    DamlPartyAllocationRejectionEntry party_allocation_rejection_entry = 9;

    // A rejection of a pre-executed submission because of out-of-time-bounds.
    DamlOutOfTimeBoundsEntry out_of_time_bounds_entry = 10;

    // A log entry whose purpose is to transmit a current record time for pre-executed submissions.
    google.protobuf.Empty time_update_entry = 101;
  }
}

message DamlLogEntryId {
  // Entry identifiers are opaque bytestrings chosen by the implementation that provide a unique
  // reference to the entry. They do not need to be comparable, as long as the implementation can
  // provide an ordered sequence of log entries.
  // The entry identifier is used:
  // * to lookup the log entry when producing `Update`.
  // * as the Daml transaction identifier and rendered as hexadecimal.
  // * as part of contract identifiers.
  bytes entry_id = 1;
}

message DamlSubmitterInfo {
  repeated string submitters = 1;
  string command_id = 2;
  string application_id = 3;
  reserved 4; // was maximum_record_time
  oneof deduplication_period {
    google.protobuf.Timestamp deduplicate_until = 5 [deprecated = true]; // Read-only for backwards compatibility
    google.protobuf.Duration deduplication_duration = 6;
    string deduplication_offset = 7;
  }
  string submission_id = 9;
}

// Daml transaction entry, used in both `DamlSubmission` and `DamlLogEntry`.
// Contains the original relative transaction as produced by Daml Engine, along
// with submitter information and metadata (see Ledger API `commands.proto` for
// their source).
message DamlTransactionEntry {
  // The original submitted transaction, with relative identifiers.
  com.daml.lf.transaction.Transaction transaction = 1;

  // The submitting party and metadata about the submitted command.
  // The submitting party is authorized against the submitting participant
  // by looking at the party allocation. The metadata is used to deduplicate
  // command submissions.
  DamlSubmitterInfo submitter_info = 2;

  // Workflow identifier is an opaque string specific to the
  // submitting application that is visible over Ledger API. The workflow
  // identifier has no predefined meaning and applications are free to use
  // it as they see fit.
  string workflow_id = 3;

  // The ledger effective time of the transaction. This timestamp is used
  // during validation/reinterpretation of the transaction as the source of
  // time. This timestamp is checked against the ledger configuration which defines
  // the bounds for valid timestamps in relation to the ledger record time
  // (the time at which the transaction is committed).
  google.protobuf.Timestamp ledger_effective_time = 4;

  // The nonce used to generate contract ids
  bytes submission_seed = 5;

  // The time used to derive contract ids
  google.protobuf.Timestamp submission_time = 6;

  // The pre-computed transaction blinding information.
  DamlTransactionBlindingInfo blinding_info = 7;
}

// A transaction's blinding information, consisting of disclosure and
// divulgence info.
//
// See com.daml.lf.transaction.BlindingInfo for more details.
message DamlTransactionBlindingInfo {
  // The disclosure of a transaction node to a set of local parties.
  message DisclosureEntry {
    string node_id = 1;
    repeated string disclosed_to_local_parties = 2;
  }

  // The divulgence of a contract to a set of local parties.
  message DivulgenceEntry {
    string contract_id = 1;
    repeated string divulged_to_local_parties = 2;
    com.daml.lf.transaction.ContractInstance contract_instance = 3;
  }

  // Disclosure, specified in terms of local transaction node IDs.
  repeated DisclosureEntry disclosures = 1;

  // Divulgence, specified in terms of contract IDs.
  // Note: if this info was produced by blinding a transaction
  // containing only contract ids, it may also contain contracts
  // produced in the same transaction.
  repeated DivulgenceEntry divulgences = 2;
}

// A transaction rejection entry.
message DamlTransactionRejectionEntry {
  DamlSubmitterInfo submitter_info = 1;
  reserved 5; // was reason.maximum_record_time_exceeded

  // Whether this rejection should be considered a definite answer; i.e., whether this rejection
  // signals that no other transaction with the same change-id can be accepted or rejected.
  //
  // False for all rejections before the rank-based deduplication is implemented.
  bool definite_answer = 22;

  oneof reason {

    // Rejections used by both participant.state v1 and v2 API.
    com.daml.ledger.participant.state.kvutils.Duplicate duplicate_command = 6;
    com.daml.ledger.participant.state.kvutils.SubmitterCannotActViaParticipant submitter_cannot_act_via_participant = 8;
    com.daml.ledger.participant.state.kvutils.InvalidLedgerTime invalid_ledger_time = 9;

    //
    // Rejections used by participant.state.v1 API.
    // Note that these are deprecated.
    //
    com.daml.ledger.participant.state.kvutils.Inconsistent inconsistent = 2 [deprecated = true];
    com.daml.ledger.participant.state.kvutils.Disputed disputed = 3 [deprecated = true];
    com.daml.ledger.participant.state.kvutils.ResourcesExhausted resources_exhausted = 4 [deprecated = true];
    com.daml.ledger.participant.state.kvutils.PartyNotKnownOnLedger party_not_known_on_ledger = 7 [deprecated = true];

    //
    // Rejections used by participant.state.v2 API.
    //
    com.daml.ledger.participant.state.kvutils.ValidationFailure validation_failure = 10;
    com.daml.ledger.participant.state.kvutils.DuplicateKeys internally_duplicate_keys = 11;
    com.daml.ledger.participant.state.kvutils.InconsistentKeys internally_inconsistent_keys = 12;
    com.daml.ledger.participant.state.kvutils.InconsistentContracts externally_inconsistent_contracts = 13;
    com.daml.ledger.participant.state.kvutils.DuplicateKeys externally_duplicate_keys = 14;
    com.daml.ledger.participant.state.kvutils.InconsistentKeys externally_inconsistent_keys = 15;
    com.daml.ledger.participant.state.kvutils.MissingInputState missing_input_state = 16;
    com.daml.ledger.participant.state.kvutils.RecordTimeOutOfRange record_time_out_of_range = 17;
    com.daml.ledger.participant.state.kvutils.CausalMonotonicityViolated causal_monotonicity_violated = 18;
    com.daml.ledger.participant.state.kvutils.SubmittingPartyNotKnownOnLedger submitting_party_not_known_on_ledger = 19;
    com.daml.ledger.participant.state.kvutils.PartiesNotKnownOnLedger parties_not_known_on_ledger = 20;
    com.daml.ledger.participant.state.kvutils.InvalidParticipantState invalid_participant_state = 21;
  }
}
// A public package upload.
// Daml-LF packages will be deduplicated based on their hashes. Only unique
// ones will be added to the key-value storage. Deduplication has no impact on the
// upload result.
message DamlPackageUploadEntry {
  // A unique string scoped to a particular participant for matching the
  // request with the result.
  // Implementers are free to select adequate mechanism e.g. UUID or similar.
  string submission_id = 1;

  // List of archives to be uploaded.
  repeated daml_lf_dev.Archive archives = 2;

  // Description provided by the backing participant describing where it got
  // the package from, e.g., when, where, or by whom the packages were
  // uploaded.
  string source_description = 3;

  // Uploading participant's id.
  string participant_id = 4;
}

// A message indicating that package upload was unsuccessful.
// If validation of any of the uploaded packages fails, the whole upload fails
// and a rejection message is produced.
message DamlPackageUploadRejectionEntry {
  // An id selected by the submitter, can be used for matching rejection with
  // the original upload entry.
  string submission_id = 1;

  // Id of the participant that uploaded the package.
  string participant_id = 2;

  oneof reason {
    com.daml.ledger.participant.state.kvutils.Invalid invalid_package = 3;
    com.daml.ledger.participant.state.kvutils.ParticipantNotAuthorized participant_not_authorized = 4;
    com.daml.ledger.participant.state.kvutils.Duplicate duplicate_submission = 5;
  }
}

// An allocation of party name and assignment of a party to a given
// participant.
// A party can only be hosted once (this may not be true in more
// sophisticated ledgers in the future).
message DamlPartyAllocationEntry {
  // A unique string scoped to a particular participant.
  // Implementers are free to select adequate mechanism e.g. UUID or similar.
  string submission_id = 1;

  // The party name to be allocated.
  string party = 2;

  // Allocating participant's id.
  string participant_id = 3;

  // A display name associated with the given party.
  string display_name = 4;
}

// A message indicating that party allocation was unsuccessful.
message DamlPartyAllocationRejectionEntry {
  // An id selected by the submitter, can be used for matching rejection with
  // the original upload entry.
  string submission_id = 1;

  // Uploading participant's id.
  string participant_id = 2;

  oneof reason {
    com.daml.ledger.participant.state.kvutils.AlreadyExists already_exists = 3;
    com.daml.ledger.participant.state.kvutils.Invalid invalid_name = 4;
    com.daml.ledger.participant.state.kvutils.ParticipantNotAuthorized participant_not_authorized = 5;
    com.daml.ledger.participant.state.kvutils.Duplicate duplicate_submission = 6;
  }
}

// Indicates that a submission has been rejected after pre-execution.
// [[KeyValueConsumption.logEntryToUpdate]] will pick the right rejection reason based on current
// record time.
message DamlOutOfTimeBoundsEntry {
  // We don't expect entry.recordTime to be present.
  DamlLogEntry entry = 1;
  google.protobuf.Timestamp duplicate_until = 2;
  google.protobuf.Timestamp too_early_until = 3;
  google.protobuf.Timestamp too_late_from = 4;
}

